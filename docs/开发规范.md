# 开发规范

## 项目结构
项目以业务模块 -> 功能分层的方式进行组织，api版本维度分层目前未涉及。

```
ProjectRoot/
├── cmd/
│ └── main.go
├── docs/
│ └── 架构设计.md
| └── 模块说明.md
| └── openapi.yaml
| └── insomnia.json
├── internal/
│ ├── user/
│ │ ├── api/
│ │ │ ├── handler.go
│ │ │ └── router.go
│ │ ├── service/
│ │ │ └── user_service.go
│ │ ├── repository/
│ │ │ ├── user_repository.go
│ │ │ └── gorm_user_repository.go
│ │ ├── model/
│ │ │ └── user.go
│ │ └── utils/
│ │   └── password.go
│ ├── order/
│ │ ├── api/
│ │ │ ├── handler.go
│ │ │ └── router.go
│ │ ├── service/
│ │ │ └── order_service.go
│ │ ├── repository/
│ │ │ ├── order_repository.go
│ │ │ └── gorm_order_repository.go
│ │ ├── model/
│ │ │ └── order.go
│ │ └── utils/
│ │   └── ...
│ ├── config/
│ │ └── config.go
│ ├── middleware/
│ │ └── middleware.go
│ └── shared/
│   └── shared.go
├── pkg/
│ └── ...
├── deploy/
│ └── config.yaml
├── go.mod
└── README.md
```

## 模块职责

| 模块       | 职责描述                                                                                                    |
| ---------- | ----------------------------------------------------------------------------------------------------------- |
| config     | 配置管理模块，负责加载和解析配置文件                                                                        |
| controller | 控制器模块，负责处理 HTTP 请求，调用服务层完成业务操作                                                      |
| handler    | 请求处理模块，定义和实现各个 API 端点及其处理逻辑                                                           |
| midware    | 中间件模块，处理请求验证、日志记录、错误处理等通用逻辑                                                      |
| record     | 数据访问模块，负责与数据库进行交互，执行数据存储、查询、更新和删除操作。以 single record 模式保证数据完整性 |
| sdkClient  | SDK 客户端模块，封装与外部服务交互的客户端逻辑                                                              |
| service    | 服务模块，包含核心业务逻辑的实现                                                                            |
| web        | request、response 参数封装                                                                                  |

## 编码规范

### 命名规范
- 变量、函数、参数和包名：使用驼峰命名法（camelCase）
- 常量：使用大写字母和下划线（SNAKE_CASE）

### 代码格式
- 使用统一的格式化工具：gofmt
- 函数长度应保持在 100 行以内
- 遵循单一职责原则
- 采用面向接口编程

## API 设计

### RESTful API 设计原则
- 使用 HTTP 动词表示操作
- 路径使用复数形式表示资源（如 `/users`、`/orders`）
- 合理使用 HTTP 状态码

### HTTP 动词使用
| 动词   | 用途     |
| ------ | -------- |
| GET    | 获取资源 |
| POST   | 创建资源 |
| PUT    | 更新资源 |
| PATCH  | 部分更新 |
| DELETE | 删除资源 |

### 状态码定义
| 状态码 | 含义                              |
| ------ | --------------------------------- |
| 200    | OK：请求成功                      |
| 400    | Bad Request：请求参数错误         |
| 401    | Unauthorized：未授权              |
| 403    | Forbidden：禁止访问               |
| 404    | Not Found：资源未找到             |
| 500    | Internal Server Error：服务器错误 |

## Service 规则

### 参数约定
- **入参 (xxxxParam)**
  - 命名规则：`xxxxParam` 其中 xxxx 为具体业务操作名称
  - 类型定义：结构体，包含所需的所有输入数据字段
  - 必须进行参数验证

- **出参 (xxxxResult)**
  - 命名规则：`xxxxResult` 其中 xxxx 为具体业务操作名称
  - 类型定义：结构体，包含操作结果和状态信息

## 日志记录

### 日志级别
| 级别  | 用途                 |
| ----- | -------------------- |
| DEBUG | 调试信息             |
| INFO  | 重要的运行信息       |
| WARN  | 警告信息，非致命错误 |
| ERROR | 致命错误             |

### 日志格式
- 采用结构化日志，便于解析和检索
- 包含：时间戳、日志级别、消息、错误堆栈等信息

## 安全规范

### 基本要求
1. **输入验证**
   - 验证所有用户输入
   - 防止 SQL 注入、XSS 等攻击

2. **身份认证和授权**
   - 使用安全的身份认证机制（如 JWT）
   - 实现细粒度的权限控制（如 RBAC）

3. **数据加密**
   - 敏感数据加密存储和传输

## 测试规范

### 1. 基本原则
- 测试文件与被测试文件放在同一目录
- 命名格式：`xxx_test.go`
- 测试函数格式：`func TestXxx(t *testing.T)`
- 独立性：测试用例互不依赖
- 可重复性：结果稳定一致
- 覆盖率要求：核心业务代码覆盖率 > 80%
- 代码整洁：测试代码同样需要保持简洁和可维护性

### 2. 测试框架使用

#### 2.1 框架选择
```go
import (
    "testing"
    "database/sql"
    . "github.com/bytedance/mockey"
    . "github.com/smartystreets/goconvey/convey"
    "github.com/DATA-DOG/go-sqlmock"
)
```

#### 2.2 基本测试结构
```go
func TestXxx(t *testing.T) {
    PatchConvey("测试场景描述", t, func() {
        // 1. 准备测试数据
        
        // 2. 执行被测试的函数
        
        // 3. 验证结果
        So(actual, ShouldEqual, expected)
    })
}
```

#### 2.3 常用断言
```go
// 相等性检查
So(actual, ShouldEqual, expected)
So(actual, ShouldNotEqual, expected)

// 空值检查
So(value, ShouldBeNil)
So(value, ShouldNotBeNil)

// 布尔检查
So(value, ShouldBeTrue)
So(value, ShouldBeFalse)

// 错误检查
So(err, ShouldBeNil)
So(err, ShouldNotBeNil)
```

### 3. Mock 使用指南

#### 3.1 函数/方法 Mock
```go
// 普通函数 Mock
Mock(targetFunction).Return(mockReturnValue).Build()

// 方法 Mock
Mock(GetMethod(targetObject, "MethodName")).Return(mockReturnValue).Build()

// 带参数验证的 Mock
Mock(targetFunction).When(arg1, arg2).Return(mockReturnValue).Build()
```

#### 3.2 数据库 Mock
```go
func TestMain(m *testing.M) {
    lzdb.Init(nil) // 初始化 mock 数据库
    os.Exit(m.Run())
}

// Mock 查询
lzdb.DbMock.ExpectQuery("SELECT (.+) FROM users").
    WithArgs(1).
    WillReturnRows(sqlmock.NewRows([]string{"id", "name"}).
    AddRow(1, "test"))

// Mock 执行
lzdb.DbMock.ExpectExec("INSERT INTO users").
    WithArgs("test").
    WillReturnResult(sqlmock.NewResult(1, 1))
```

#### 3.3 HTTP 请求 Mock
```go
func TestHTTPHandler(t *testing.T) {
    PatchConvey("测试 HTTP Handler", t, func() {
        w := httptest.NewRecorder()
        c, _ := gin.CreateTestContext(w)
        
        // 设置请求
        c.Request, _ = http.NewRequest("GET", "/test", nil)
        
        // 执行处理器
        handler(c)
        
        // 验证响应
        So(w.Code, ShouldEqual, http.StatusOK)
    })
}
```

### 4. 最佳实践

#### 4.1 表驱动测试
```go
func TestFunction(t *testing.T) {
    PatchConvey("表驱动测试", t, func() {
        tests := []struct {
            name     string
            input    interface{}
            expected interface{}
        }{
            {"正常场景", input1, expected1},
            {"边界场景", input2, expected2},
            {"异常场景", input3, expected3},
        }

        for _, tt := range tests {
            PatchConvey(tt.name, func() {
                result := Function(tt.input)
                So(result, ShouldEqual, tt.expected)
            })
        }
    })
}
```

#### 4.2 测试用例组织
```go
func TestXxx(t *testing.T) {
    PatchConvey("功能模块", t, func() {
        // 初始化测试环境
        
        PatchConvey("正常场景", func() {
            // 测试正常流程
        })
        
        PatchConvey("异常场景", func() {
            // 测试异常流程
        })
        
        PatchConvey("边界场景", func() {
            // 测试边界条件
        })
    })
}
```

### 5. 注意事项

#### 5.1 测试范围
- 重点关注核心业务逻辑
- 必须测试错误处理逻辑
- 覆盖边界条件和异常场景

#### 5.2 Mock 使用建议
- 优先使用依赖注入而非全局变量
- Mock 要符合实际业务逻辑
- 及时清理 Mock 数据和环境

#### 5.3 测试维护
- 定期更新测试用例
- 删除过时的测试
- 保持测试代码的整洁和可读性

### 6. 常见问题解决

#### 6.1 测试初始化
```go
func TestMain(m *testing.M) {
    // 1. 初始化测试环境
    setup()
    
    // 2. 运行测试
    code := m.Run()
    
    // 3. 清理环境
    teardown()
    
    os.Exit(code)
}
```

#### 6.2 并发测试
```go
func TestConcurrent(t *testing.T) {
    PatchConvey("并发测试", t, func() {
        var wg sync.WaitGroup
        for i := 0; i < 10; i++ {
            wg.Add(1)
            go func() {
                defer wg.Done()
                // 测试代码
            }()
        }
        wg.Wait()
    })
}
```

## 文档要求
1. **API 文档**
   - 使用 OpenAPI 文档
   - 生成对应的接口测试文档：Insomnia
   - 保持文档与代码的一致性

2. **开发文档**
   - 架构设计
   - 模块说明
   - 接口定义
