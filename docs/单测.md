# Go 单元测试规范

## 一、基本原则

### 1.1 测试文件规范
- 测试文件与被测试文件放在同一目录
- 命名格式：`xxx_test.go`
- 测试函数格式：`func TestXxx(t *testing.T)`

### 1.2 测试原则
- 独立性：测试用例互不依赖
- 可重复性：结果稳定一致
- 覆盖率要求：核心业务代码覆盖率 > 80%
- 代码整洁：测试代码同样需要保持简洁和可维护性

## 二、测试框架使用

### 2.1 框架选择
```go
import (
    "testing"
    "database/sql"
    . "github.com/bytedance/mockey"
    . "github.com/smartystreets/goconvey/convey"
    "github.com/DATA-DOG/go-sqlmock"
)
```

### 2.2 基本测试结构
```go
func TestXxx(t *testing.T) {
    PatchConvey("测试场景描述", t, func() {
        // 1. 准备测试数据
        
        // 2. 执行被测试的函数
        
        // 3. 验证结果
        So(actual, ShouldEqual, expected)
    })
}
```

### 2.3 常用断言
```go
// 相等性检查
So(actual, ShouldEqual, expected)
So(actual, ShouldNotEqual, expected)

// 空值检查
So(value, ShouldBeNil)
So(value, ShouldNotBeNil)

// 布尔检查
So(value, ShouldBeTrue)
So(value, ShouldBeFalse)

// 错误检查
So(err, ShouldBeNil)
So(err, ShouldNotBeNil)
```

## 三、Mock 使用指南

### 3.1 函数/方法 Mock
```go
// 普通函数 Mock
Mock(targetFunction).Return(mockReturnValue).Build()

// 方法 Mock
Mock(GetMethod(targetObject, "MethodName")).Return(mockReturnValue).Build()

// 带参数验证的 Mock
Mock(targetFunction).When(arg1, arg2).Return(mockReturnValue).Build()
```

### 3.2 数据库 Mock
```go
func TestMain(m *testing.M) {
    lzdb.Init(nil) // 初始化 mock 数据库
    os.Exit(m.Run())
}

// Mock 查询
lzdb.DbMock.ExpectQuery("SELECT (.+) FROM users").
    WithArgs(1).
    WillReturnRows(sqlmock.NewRows([]string{"id", "name"}).
    AddRow(1, "test"))

// Mock 执行
lzdb.DbMock.ExpectExec("INSERT INTO users").
    WithArgs("test").
    WillReturnResult(sqlmock.NewResult(1, 1))
```

### 3.3 HTTP 请求 Mock
```go
func TestHTTPHandler(t *testing.T) {
    PatchConvey("测试 HTTP Handler", t, func() {
        w := httptest.NewRecorder()
        c, _ := gin.CreateTestContext(w)
        
        // 设置请求
        c.Request, _ = http.NewRequest("GET", "/test", nil)
        
        // 执行处理器
        handler(c)
        
        // 验证响应
        So(w.Code, ShouldEqual, http.StatusOK)
    })
}
```

## 四、最佳实践

### 4.1 表驱动测试
```go
func TestFunction(t *testing.T) {
    PatchConvey("表驱动测试", t, func() {
        tests := []struct {
            name     string
            input    interface{}
            expected interface{}
        }{
            {"正常场景", input1, expected1},
            {"边界场景", input2, expected2},
            {"异常场景", input3, expected3},
        }

        for _, tt := range tests {
            PatchConvey(tt.name, func() {
                result := Function(tt.input)
                So(result, ShouldEqual, tt.expected)
            })
        }
    })
}
```

### 4.2 测试用例组织
```go
func TestXxx(t *testing.T) {
    PatchConvey("功能模块", t, func() {
        // 初始化测试环境
        
        PatchConvey("正常场景", func() {
            // 测试正常流程
        })
        
        PatchConvey("异常场景", func() {
            // 测试异常流程
        })
        
        PatchConvey("边界场景", func() {
            // 测试边界条件
        })
    })
}
```

## 五、注意事项

### 5.1 测试范围
- 重点关注核心业务逻辑
- 必须测试错误处理逻辑
- 覆盖边界条件和异常场景

### 5.2 Mock 使用建议
- 优先使用依赖注入而非全局变量
- Mock 要符合实际业务逻辑
- 及时清理 Mock 数据和环境

### 5.3 测试维护
- 定期更新测试用例
- 删除过时的测试
- 保持测试代码的整洁和可读性

## 六、常见问题解决

### 6.1 测试初始化
```go
func TestMain(m *testing.M) {
    // 1. 初始化测试环境
    setup()
    
    // 2. 运行测试
    code := m.Run()
    
    // 3. 清理环境
    teardown()
    
    os.Exit(code)
}
```

### 6.2 并发测试
```go
func TestConcurrent(t *testing.T) {
    PatchConvey("并发测试", t, func() {
        var wg sync.WaitGroup
        for i := 0; i < 10; i++ {
            wg.Add(1)
            go func() {
                defer wg.Done()
                // 测试代码
            }()
        }
        wg.Wait()
    })
}
```

